<html>
  <head>
    <title>Auth to the server.</title>
    <script>
      // TODO: THIS IS ACTUALLY SUPPOSED TO BE SERVER LOGIC.
      const challengeBytes = new Uint8Array(16);
      window.crypto.getRandomValues(challengeBytes);

      // Following the overview from https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#registration
      async function RegisterNewUser() {
        // The first step already happened, we have the credential preferences of the the auth server embedded into this script.
        const step0 = Step0_AuthServerResponse();

        // credentials.create is what actually triggers the U2F to create a new key-pair with the auth server's requirements.
        // https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential
        const publicKeyCredential = await navigator.credentials.create({ publicKey: step0 });

        const step6Response = Step6_AuthServerValidatesResponse(publicKeyCredential);

        if (step6Response.isOk()) {
           window.localStorage.setItem('userid', publicKeyCredential.rawId);
        } else {
           console.log(step6Response.message());
        }
      }

      function Step0_AuthServerResponse() {
        // https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions
        return {
          challenge: challengeBytes,
          rp: {
            name: 'Sandr.io (localhost)',
            id: 'localhost'
          },
          user: {
            id: new TextEncoder().encode("sandro"),
            displayName: 'Sandro!',
            name: 'Sandro'
          },
          challenge: challengeBytes,
          // publicKey.pubKeyCredParams is missing at least one of the default algorithm identifiers: ES256 and RS256. This can result in registration failures on incompatible authenticators. See https://chromium.googlesource.com/chromium/src/+/master/content/browser/webauth/pub_key_cred_params.md for details
          pubKeyCredParams: [ { alg: -7 /* cose_alg_ECDSA_w_SHA256 */, type: 'public-key' } ],
          authenticatorSelection: {
            authenticatorAttachment: 'cross-platform',
            requireResidentKey: false,
            userVerification: 'preferred'
          },
          attestation: undefined,
          timeout: 60 * 1000,  // 1 minute
          excludeCredentials: [], // No excludeList
          extensions: { "exts": true }
        };
      }

      function Step6_AuthServerValidatesResponse(publicKeyCredential) {
        if (publicKeyCredential.type !== 'public-key') throw "Didn't get a Public Key from credentials.create: " + publicKeyCredential.type;
        const userId = publicKeyCredential.rawId;
        const clientData = publicKeyCredential.response.clientDataJSON

        // Send data to the server to verify...
        //   1. Verifying that the challenge is the same as the challenge that was sent
        //   2. Ensuring that the origin was the origin expected
        //   3. Validating that the signature over the clientDataHash and the attestation using the certificate chain for that specific model of the authenticator
        return {
          isOk: () => true,
          message: () => '',
        }
      }

      // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#authentication
      async function AuthenticateExistingUser() {
        const step0 = Step0_AuthServerResponse_Authenticate();

        // credentials.get is what actually triggers the U2F to fetch a key-pair matching the auth server requirements.
        // https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get
        const publicKeyCredential = await navigator.credentials.get({publicKey: step0});

        const step6Response = Step6_AuthServerValidatesResponse_Authenticate(publicKeyCredential);
        if (!step6Response.isOk()) {
           console.log(step6Response.message());
        } else {
           console.log('Logged in', publicKeyCredential.response.clientDataJSON);
        }
      }

      function Step0_AuthServerResponse_Authenticate() {
        // https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions
        // publicKey.userVerification was not set to any value in Web Authentication navigator.credentials.get() call. This defaults to 'preferred', which is probably not what you want. If in doubt, set to 'discouraged'. See https://chromium.googlesource.com/chromium/src/+/master/content/browser/webauth/uv_preferred.md for details.
        return {
          challenge: challengeBytes,
          rpId: 'localhost',
          timeout: 60 * 1000, // 1 minute
          allowList: [
            {
              type: "public-key",
              id: Uint8Array.from(window.localStorage.getItem('userid')),
              transports: ["usb", "nfc", "ble"],
            },
          ]
        };
      }

      function hasExistingHistory() {
        return window.localStorage.getItem('userid') !== null;
      }

    </script>
  </head>
  <body>
    <h1>WebAuthN</h1>
    <button id="create">Create Account</button>
    <button id="login">Login</button>
    <div id="log"></div>
    <script>
      document.getElementById('create').onclick = () => {
        console.log('Create Account');
        RegisterNewUser();
      };

      document.getElementById('login').onclick = () => {
        console.log('Login');
        AuthenticateExistingUser();
      };

      if (hasExistingHistory()) {
        document.getElementById('log').innerText = 'There is an existing user.';
      } else {
        document.getElementById('log').innerText = 'No existing user records found.';
      }

    </script>
  </body>
</html>
