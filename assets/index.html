<html>
  <head>
    <title>Auth to the server.</title>
    <script>

      const STATUS_OK = {isOk: () => true, message: () => ''};

      // TODO: Figure out how to store the public key across sessions.
      // localStorage requires me to figure out how to serialize an array to a string.
      RAW_ID = null;

      // TODO: THIS IS ACTUALLY SUPPOSED TO BE SERVER LOGIC.
      const challengeBytes = new Uint8Array(16);
      window.crypto.getRandomValues(challengeBytes);

      // Following the overview from https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#registration
      async function RegisterNewUser() {
        // The first step already happened, we have the credential preferences of the the auth server embedded into this script.
        const step0 = Step0_AuthServerResponse();

        // credentials.create is what actually triggers the U2F to create a new key-pair with the auth server's requirements.
        // https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential
        const publicKeyCredential = await navigator.credentials.create({ publicKey: step0 });
        console.log('navigator.credentials.create', {publicKey: step0}, publicKeyCredential);

        const step6Response = Step6_AuthServerValidatesResponse(publicKeyCredential);

        if (step6Response.isOk()) {
           RAW_ID = publicKeyCredential.rawId;
           window.localStorage.setItem('userid', publicKeyCredential.id);
        } else {
           console.log(step6Response.message());
        }
      }

      function Step0_AuthServerResponse() {
        // https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions
        return {
          challenge: challengeBytes,
          rp: {
            name: 'Sandr.io (localhost)',
          },
          user: {
            id: new TextEncoder().encode("sandro"),
            displayName: 'Sandro!',
            name: 'Sandro'
          },
          // https://w3c.github.io/webauthn/#sctn-alg-identifier
          pubKeyCredParams: [
            { type: 'public-key', alg: -7 /* ES256 */ },
            { type: 'public-key', alg: -257 /* RS256 */ },
          ],
          authenticatorSelection: {
            authenticatorAttachment: 'cross-platform', // Enables devices that are removeable.
            requireResidentKey: false,
            userVerification: 'preferred'
          },
          timeout: 60 * 1000,  // 1 minute
          excludeCredentials: [], // No excludeList
          extensions: { exts: true }
        };
      }

      function Step6_AuthServerValidatesResponse(publicKeyCredential) {
        if (publicKeyCredential.type !== 'public-key') throw "Didn't get a Public Key from credentials.create: " + publicKeyCredential.type;
        const userId = publicKeyCredential.id;
        const clientData = publicKeyCredential.response.clientDataJSON

        // Send data to the server to verify...
        //   1. Verifying that the challenge is the same as the challenge that was sent
        //   2. Ensuring that the origin was the origin expected
        //   3. Validating that the signature over the clientDataHash and the attestation using the certificate chain for that specific model of the authenticator
        return STATUS_OK;
      }

      // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#authentication
      async function AuthenticateExistingUser() {
        const step0 = Step0_AuthServerResponse_Authenticate();

        // credentials.get is what actually triggers the U2F to fetch a key-pair matching the auth server requirements.
        // https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get
        console.log('navigator.credentials.get', {publicKey: step0});
        const publicKeyCredential = await navigator.credentials.get({publicKey: step0});
        console.log('navigator.credentials.get', {publicKey: step0}, publicKeyCredential);

        const step6Response = Step6_AuthServerValidatesResponse_Authenticate(publicKeyCredential);
        if (!step6Response.isOk()) {
           console.log(step6Response.message());
        } else {
           console.log('Logged in', publicKeyCredential.response.clientDataJSON);
        }
      }

      function Step0_AuthServerResponse_Authenticate() {
        // https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions
        return {
          challenge: challengeBytes,
          userVerification: 'discouraged', // https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
          allowCredentials: [
            {
              type: "public-key",
              id: RAW_ID,
              transports: ["usb", "nfc", "ble"],
            },
          ],
        };
      }

      function Step6_AuthServerValidatesResponse_Authenticate(publicKeyCredential) {
        return STATUS_OK;
      }

      function hasExistingHistory() {
        return window.localStorage.getItem('userid') !== null;
      }
    </script>
  </head>
  <body>
    <h1>WebAuthN</h1>
    <button id="create">Create Account</button>
    <button id="login">Login</button>
    <div id="log"></div>
    <script>
      document.getElementById('create').onclick = () => {
        console.log('Create Account');
        RegisterNewUser();
      };

      document.getElementById('login').onclick = () => {
        console.log('Login');
        AuthenticateExistingUser();
      };

      if (hasExistingHistory()) {
        document.getElementById('log').innerText = 'There is an existing user: ' + window.localStorage.getItem('userid');
      } else {
        document.getElementById('log').innerText = 'No existing user records found.';
      }

    </script>
  </body>
</html>
